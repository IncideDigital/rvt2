[common]
plugindir:
description.file: ${plugindir}/README.md

[wait_for_job]
modules:
  base.threads.WaitForJob job_name={job_name}

[copy_file]
modules:
  base.commands.Command cmd="if [ -e '{outfile}' ]; then rm '{outfile}'; fi && if [ -e '{infile}' ]; then mkdir -p $$(dirname '{outfile}') && cp '{infile}' '{outfile}'; fi"
default_params: {'outfile': '',
  'infile': ''}

;;;;;;;;;;;; MOUNTING IMAGES

[mount]
description: Mount all partitions of a disk image.

    See plugins.common.RVT_mount.Mount module for more parameters.

    Examples:

    - Mount all partitions in an image: `rvt2 --source 01 -j mount`
    - Mount an image with a bitlocker partition: `rvt2 --source 01 -j mount --params recovery_keys=0000-1111-....`

help_section: common
modules:
  plugins.common.RVT_mount.Mount vss={vss} recovery_keys="{recovery_keys}" password="{password}" partitions="{partitions}" remove_info="{remove_info}"
default_params: {
  'vss':False,
  'recovery_keys':'${plugins.common.RVT_mount.Mount:recovery_keys}',
  'password':'${plugins.common.RVT_mount.Mount:password}',
  'partitions':'',
  'remove_info':False}
params_help: {
  'path':'If provided, it is an absolute path to the image to mount. If not provided, mount `${imagedir}/${source}.extension`, where extension is 001, dd, raw, aff, aff4, vmdx (experimental), zip or tar',
  'vss':'If True and the image is a Windows OS, mount Virtual Shadows',
  'partitions':'comma separated list of partitions to mount. Ex: "p03,p05,v1p05"',
  'recovery_keys':'comma separated list of recovery keys for bitlocker encrypted partitions',
  'password':'password for FileVault encrypted volume',
  'remove_info':'if True, remove previous information gathered about disk. Use this if any error occurs'}

[umount]
description: Unmount all partitions of a disk image
help_section: common
modules:
  plugins.common.RVT_mount.UMount remove_info="{remove_info}"
default_params: {'mountdir':'${mountdir}',
  'remove_info':False}
params_help: {
  'path':'If provided, it is an absolute path to the image to unmount. If not provided, unmount `${imagedir}/${source}.extension`, where extension is 001, dd, raw, aff, aff4, vmdx (experimental), zip or tar',
  'mountdir':'unmount all mounted partitions in mountdir. Can be set on "DEFAULT" configuration option',
  'remove_info':'if True, remove previous information gathered about disk. Use this if any error occurs'}


;;;;;;;;;;;; TIMELINES

[fs_timeline]
description: Generate a timeline of a filesystem.

  The output will be in "${outdir}". In this directory:

  - `${outdir}/${source}_BODY.csv`: The BODY file, created by fls: for each file in the source, a line including all its timestamps
  - `${outdir}/${source}_TL.csv`: The timeline file, created by mactime: actions "macb" on all files in the source, ordered by date
  - `${outdir}/${source}_hour_sum.csv`: stats on the timeline file, grouped by hours

help_section: common
modules:
    plugins.common.RVT_timelines.Timelines vss={vss} outdir="{outdir}"
outdir: ${plugins.common.RVT_timelines.Timelines:outdir}
default_params: {'vss':False,
  'outdir':'${outdir}',
  'summary': True,
  'time_range': 'hour'}
params_help: {
  'path':'If provided, it is the imagefile or device. If not, the module uses ${imagedir}/${source}.extension, where extension is 001, dd, raw, aff, aff4, zip or vmdx',
  'vss':'Create the timeline for a Volume Shadow Snapshots source',
  'outdir':'Save body and timeline this directory. Many other modules depend on this files. Do not change outdir unless you know what you are doing',
  'summary':'Generate a summary of files by `time_range`',
  'time_range':'Time range for buckets to split the timeline in the summary. Options: `hour` and `day`'}

[mft_timeline_default]
help_section: common
description: Generate a timeline for all partitions with a `$$MFT` file
modules:
  base.mutations.ForEach run_job=mft_timeline_aux
  base.mutations.SetFields fields='{{{{"volume_id":"{{filename}}"}}}}'
  base.mutations.CommonFields
  base.directory.GlobFilter ftype='directory' recursive=False
  base.mutations.MirrorOptions include_section=True relative_path=False
path: ${mountdir}/p*
outdir: ${plugins.common.RVT_timelines.Timelines:outdir}
default_params: {
  'mactime':'${plugins.common:mactime}',
  ; 'cmd':'env WINEDEBUG=fixme-all wine {executable} -f {path} --body {outdir} --bodyf {filename} --bdl c --nl',
  ; 'cmd':'env WINEDEBUG=fixme-all ${plugins.windows:wine_docker} --input={hive} --output={outdir} sh wine {executable} -f {path} --body {outdir} --bodyf {filename} --bdl c --nl',
  ; 'cmd':'{executable} -f {path} --bodystd --bodyfull -b {outdir}/{filename}',
  'cmd':'{windows_tool} {executable} -f {path} --body {outdir} --bodyf {filename} --bdl c',
  'executable':'${plugins.windows:windows_tools_dir}/MFTECmd/MFTECmd.dll',
  ; 'executable':'${plugins.windows:windows_tools_dir}/MFTECmd.exe',
  ; 'executable':'${plugins.common:analyzemft}',
  ; 'windows_format': True,
  'windows_tool': '${plugins.windows:dotnet_dir}/dotnet',
  'windows_format': False,
  'outdir':'${outdir}',
  'summary': True,
  'time_range': 'hour',
  ; 'drive_letter':'c:',
  'drive_letter':'',
  'source':'${DEFAULT:source}',
  'mountdir':'${DEFAULT:mountdir}'}
params_help: {
  'path': 'path to the $$MFT file',
  'cmd': 'external command to parse MFT. It is a Python string template accepting variables "executable", "path", "outdir" and "filename". Variable "filename" is automatically set by the job. The rest are the same ones specified in parameters',
  'executable': 'path to executable app to parse MFT',
  'windows_tool': 'in a non Windows environment, path to the tool needed to run the executable, such as "wine" or "dotnet"',
  'windows_format': 'set to True if paths must be converted to windows format for execution. For example using wine',
  'volume_id': 'volume identifier, such as partition number. Ex: p03',
  'outdir': 'save body and timeline this directory. Many other modules depend on this files. Do not change outdir unless you know what you are doing',
  'summary': 'generate a summary of files by `time_range`',
  'time_range': 'time range for buckets to split the timeline in the summary. Options: `hour` and `day`',
  'drive_letter': 'remove this information from the output. Ex: "c:". By default it substitutes any disk letter followed by :'}

[mft_timeline_aux]
jobs:
  mft_timeline path="{path}/$$MFT" volume_id="{volume_id}"

[mft_timeline]
description: Generate a timeline given an $$MFT file.

  The output will be in "${outdir}". In this directory:

  - `${outdir}/${source}_BODY.csv`: The BODY file, created by fls: for each file in the source, a line including all its timestamps
  - `${outdir}/${source}_TL.csv`: The timeline file, created by mactime: actions "macb" on all files in the source, ordered by date
  - `${outdir}/${source}_hour_sum.csv`: if `summary` parameter is set to True, stats on the timeline file, grouped by `time_range`

  Set the external command to run in the parameter `cmd`. At this moment a couple of tools are allowed:
  - `MFTECmd.exe`: Requires Windows environment. Recommended configuration:
    - `executable`: `${plugins.windows:windows_tools_dir}/MFTECmd.exe`,
    - `cmd`: `env WINEDEBUG=fixme-all wine {executable} -f {path} --body {outdir} --bodyf {filename} --bdl c --nl`
    - `windows_format`: True
    - `drive_letter`: `c:`

  - `analyzeMFT.py`: Recommended configuration:
    - `executable`: `${plugins.common:analyzemft}`,
    - `cmd`: `{executable} -f {path} --bodystd --bodyfull -b {outdir}/{filename}`
    - `windows_format`: False
    - `drive_letter`: ``

help_section: common
modules:
  plugins.common.RVT_timelines.MFTTimeline outdir="{outdir}" volume_id="{volume_id}" cmd="{cmd}" executable="{executable}" summary="{summary}" time_range="{time_range}" windows_format="{windows_format}" drive_letter="{drive_letter}"
outdir: ${plugins.common.RVT_timelines.Timelines:outdir}
default_params: {
  'mactime':'${plugins.common:mactime}',
  'volume_id':'p01',
  ; 'cmd':'env WINEDEBUG=fixme-all wine {executable} -f {path} --body {outdir} --bodyf {filename} --bdl c --nl',
  ; 'cmd':'env WINEDEBUG=fixme-all ${plugins.windows:wine_docker} --input={hive} --output={outdir} sh wine {executable} -f {path} --body {outdir} --bodyf {filename} --bdl c --nl',
  ; 'cmd':'{executable} -f {path} --bodystd --bodyfull -b {outdir}/{filename}',
  'cmd':'{windows_tool} {executable} -f {path} --body {outdir} --bodyf {filename} --bdl c',
  'executable':'${plugins.windows:windows_tools_dir}/MFTECmd/MFTECmd.dll',
  ; 'executable':'${plugins.windows:windows_tools_dir}/MFTECmd.exe',
  ; 'executable':'${plugins.common:analyzemft}',
  ; 'windows_format': True,
  'windows_format': False,
  'windows_tool': '${plugins.windows:dotnet_dir}/dotnet',
  'outdir':'${outdir}',
  'summary': True,
  'time_range': 'hour',
  ; 'drive_letter':'c:',
  'drive_letter':'',
  'source':'${DEFAULT:source}',
  'mountdir':'${DEFAULT:mountdir}'}
params_help: {
  'path': 'path to the $$MFT file',
  'cmd': 'external command to parse MFT. It is a Python string template accepting variables "executable", "path", "outdir" and "filename". Variable "filename" is automatically set by the job. The rest are the same ones specified in parameters',
  'executable': 'path to executable app to parse MFT',
  'windows_format': 'set to True if paths must be converted to windows format for execution. For example using wine',
  'volume_id': 'volume identifier, such as partition number. Ex: p03',
  'outdir': 'save body and timeline this directory. Many other modules depend on this files. Do not change outdir unless you know what you are doing',
  'summary': 'generate a summary of files by `time_range`',
  'time_range': 'time range for buckets to split the timeline in the summary. Options: `hour` and `day`'}
path: ${mountdir}/p01/$$MFT

[allocfiles]
description: Generate allocated files in a disk image
help_section: common
modules:
    plugins.common.RVT_files.Files outdir={outdir}
default_params: {'outdir':'${plugins.common.RVT_files.Files:outdir}'}
params_help: {'outdir':'path to directory where generated files will be stored. Many other modules depend on this files. Do not change outdir unless you know what you are doing'}


;;;;;;;;;;;;; BROWSERS

[browsers]
description: Parse history, downloads and cookies from most used browsers: Chrome, Firefox, Safari, Edge, InternetExplorer
; yet to implement a way to refer to outdir
help_section: common
jobs:
  base.directory.DirectoryClear target={outdir}
  browsers.main outdir={outdir}
  browsers.history outdir={outdir}
  browsers.downloads outdir={outdir}
  browsers.cookies outdir={outdir}
default_params: {'outdir':'${plugins.common.RVT_browsers.Firefox:outdir}'}
params_help: {
  'outdir':'path to directory where generated files will be stored'}

[browsers.history]
modules:
  base.commands.Command cmd="mv /tmp/browserstemp {outfile}"
  base.commands.Command cmd="awk 'NR == 1; NR > 1 {{{{print $$0 | \"sort -n\"}}}}' {outfile}" stdout="/tmp/browserstemp"
  base.output.CSVSink outfile="{outfile}" file_exists=OVERWRITE fieldnames="last_visit visit_date url title visit_count visit_type type_description VisitSource visit_duration modified last_checked redirect_urls browser partition user profile"
  base.input.JSONReader check_path_exists=False
outdir: ${plugins.common.RVT_browsers.Firefox:outdir}
default_params: {'outfile':'${outdir}/history.csv'}
path: ${outdir}/history.json

[browsers.downloads]
modules:
  base.output.CSVSink outfile="{outfile}" file_exists=OVERWRITE fieldnames="end start url path size opened bytes_so_far total_to_load browser partition user profile"
  base.mutations.GetFields fields='["end", "start","url", "path", "size", "opened", "bytes_so_far", "total_to_load", "browser", "partition", "user", "profile"]'
  base.input.JSONReader check_path_exists=False
outdir: ${plugins.common.RVT_browsers.Firefox:outdir}
path: ${outdir}/downloads.json
default_params: {'outfile':'${outdir}/downloads.csv'}

[browsers.cookies]
modules:
  base.commands.Command cmd="mv /tmp/browserstemp {outfile}"
  base.commands.Command cmd="awk 'NR == 1; NR > 1 {{{{print $$0 | \"sort -n\"}}}}' {outfile}" stdout="/tmp/browserstemp"
  base.output.CSVSink outfile="{outfile}" file_exists=OVERWRITE fieldnames="accessed creation expires url cookie_name cookie_value path flag browser partition user profile"
  base.mutations.GetFields fields='["accessed", "creation", "expires", "url", "cookie_name", "cookie_value", "path", "flag", "browser", "partition", "user", "profile"]'
  base.input.JSONReader check_path_exists=False
outdir: ${plugins.common.RVT_browsers.Firefox:outdir}
default_params: {'outfile':'${outdir}/cookies.csv'}
path: ${outdir}/cookies.json

[browsers.main]
modules:
  plugins.common.RVT_files.SendAllocFiles
  browsers.parser outdir={outdir}
default_params: {'outdir':'${plugins.common.RVT_browsers.Firefox:outdir}'}
params_help: {
  'outdir':'path to directory where generated files will be stored'}

[browsers.parser]
description: Call different parsers for different browsers databases
inherits = base.directory.FileParser
parsers =
  ".*(Google/Chrome|/chromium|\.chrome).*/History$$" browsers.chrome.history
  ".*(Google/Chrome|/chromium|\.chrome).*/History$$" browsers.chrome.downloads
  ".*(Google/Chrome|/chromium|\.chrome).*/Cookies$$" browsers.chrome.cookies
  ".*/BraveSoftware/Brave-Browser/User Data/.*/History$$" browsers.brave.history
  ".*/BraveSoftware/Brave-Browser/User Data/.*/History$$" browsers.brave.downloads
  ".*/BraveSoftware/Brave-Browser/User Data/.*/Cookies$$" browsers.brave.cookies
  ".*/Vivaldi/.*/History$$" browsers.vivaldi.history
  ".*/Vivaldi/.*/History$$" browsers.vivaldi.downloads
  ".*/Vivaldi/.*/Cookies$$" browsers.vivaldi.cookies
  ".*/Opera Software/.*/History$$" browsers.opera.history
  ".*/Opera Software/.*/History$$" browsers.opera.downloads
  ".*/Opera Software/.*/Cookies$$" browsers.opera.cookies
  ".*Microsoft/Edge/User Data/Default/History$$" browsers.edge_legacy.history
  ".*Microsoft/Edge/User Data/Default/History$$" browsers.edge_legacy.downloads
  ".*Microsoft/Edge/User Data/Default/Cookies$$" browsers.edge_legacy.cookies
  ".*/[Ff]irefox/.*/places.sqlite$$" browsers.firefox.history
  ".*/[Ff]irefox/.*/places.sqlite$$" browsers.firefox.downloads
  ".*/[Ff]irefox/.*/.*cookies.sqlite$$" browsers.firefox.cookies
  ".*/Moonchild Productions/Pale Moon/.*/places.sqlite$$" browsers.palemoon.history
  ".*/Moonchild Productions/Pale Moon/.*/places.sqlite$$" browsers.palemoon.downloads
  ".*/Moonchild Productions/Pale Moon/.*cookies.sqlite$$" browsers.palemoon.cookies
  ".*/WebCacheV0[12].dat$$" browsers.edge.history
  ".*/WebCacheV0[12].dat$$" browsers.edge.cookies
  ".*/WebCacheV0[12].dat$$" browsers.edge.downloads
  ".*/History/History.IE5/(Low/|MSHist[\d*]/)?index.dat$$" browsers.internet_explorer
  ".*/(Library|Apple Computer)/Safari/History.db$$" browsers.safari.history_db
  ".*/(Library|Apple Computer)/Safari/History.plist$$" browsers.safari.history_plist
  ".*/(Library|Apple Computer)/Safari/Downloads.plist$$" browsers.safari.downloads
  ".*/(Library|Apple Computer)/Cookies/Cookies.binarycookies$$" browsers.safari.cookies

[browsers.chrome.history]
modules =
	base.output.JSONSink file_exists=APPEND outfile="${plugins.common.RVT_browsers.Chrome:outdir}/history.json"
  plugins.common.ExtractPathTerms section='browsers.parameters'
  base.mutations.AddFields section='browsers.parameters' fields='{{{{"partition":"{{partition}}", "user":"{{user}}", "browser":"chrome", "profile":"{{profile}}"}}}}'
	base.input.SQLiteReader read_only=True
query =
  SELECT DATETIME(urls.last_visit_time/1000000-11644473600,'unixepoch') AS last_visit,
  DATETIME(visits.visit_time/1000000-11644473600,'unixepoch') AS visit_date,
  urls.url AS url,
  REPLACE(urls.title,'|','/') AS title,
  urls.visit_count AS visit_count,
  visits.transition & 255 AS visit_type,
  CASE (visits.transition & 255)
  WHEN 0 THEN 'User clicked a link'
  WHEN 1 THEN 'User typed the URL in the URL bar'
  WHEN 2 THEN 'Got through a suggestion in the UI'
  WHEN 3 THEN 'Content automatically loaded in a non-toplevel frame - user may not realize'
  WHEN 4 THEN 'Subframe explicitly requested by the user'
  WHEN 5 THEN 'User typed in the URL bar and selected an entry from the list - such as a search bar'
  WHEN 6 THEN 'The start page of the browser'
  WHEN 7 THEN 'A form the user has submitted values to'
  WHEN 8 THEN 'The user reloaded the page, eg by hitting the reload button or restored a session'
  WHEN 9 THEN 'URL what was generated from a replacable keyword other than the default search provider'
  WHEN 10 THEN 'Corresponds to a visit generated from a KEYWORD' END AS type_description,
  visits.visit_duration AS visit_duration,
  CASE visit_source.source
  WHEN 0 THEN 'Synced'
  WHEN 1 THEN 'Browsed'
  WHEN 2 THEN 'Extension'
  WHEN 3 THEN 'Imported'
  WHEN 4 THEN 'Imported'
  WHEN 5 THEN 'Imported'
  END AS VisitSource
  FROM visits JOIN urls ON urls.id = visits.url LEFT JOIN visit_source ON visit_source.id = visits.id

[browsers.chrome.downloads]
modules =
	base.output.JSONSink file_exists=APPEND outfile="${plugins.common.RVT_browsers.Chrome:outdir}/downloads.json"
  plugins.common.ExtractPathTerms section='browsers.parameters'
  base.mutations.AddFields section='browsers.parameters' fields='{{{{"partition":"{{partition}}", "user":"{{user}}", "browser":"chrome", "profile":"{{profile}}"}}}}'
	base.input.SQLiteReader read_only=True
query =
  SELECT DATETIME(downloads.end_time/1000000-11644473600,'unixepoch') AS end,
  DATETIME(downloads.start_time/1000000-11644473600,'unixepoch') AS start,
  downloads.id, downloads_url_chains.url, downloads.total_bytes AS size, downloads.target_path AS path, downloads_url_chains.chain_index, downloads.opened
  FROM downloads, downloads_url_chains WHERE downloads_url_chains.id = downloads.id ORDER BY downloads.end_time

[browsers.chrome.cookies]
modules =
	base.output.JSONSink file_exists=APPEND outfile="${plugins.common.RVT_browsers.Chrome:outdir}/cookies.json"
  plugins.common.ExtractPathTerms section='browsers.parameters'
  base.mutations.AddFields section='browsers.parameters' fields='{{{{"partition":"{{partition}}", "user":"{{user}}", "browser":"chrome", "profile":"{{profile}}"}}}}'
	base.input.SQLiteReader read_only=True
query =
  SELECT DATETIME(last_access_utc/1000000-11644473600,'unixepoch') AS accessed,
  DATETIME(creation_utc/1000000-11644473600,'unixepoch') AS creation,
  host_key AS url,
  name AS cookie_name,
  value AS cookie_value
  FROM cookies

[browsers.brave.history]
modules =
	base.output.JSONSink file_exists=APPEND outfile="${plugins.common.RVT_browsers.Chrome:outdir}/history.json"
  plugins.common.ExtractPathTerms section='browsers.parameters'
  base.mutations.AddFields section='browsers.parameters' fields='{{{{"partition":"{{partition}}", "user":"{{user}}", "browser":"brave"}}}}'
	base.input.SQLiteReader read_only=True
query =
  SELECT DATETIME(urls.last_visit_time/1000000-11644473600,'unixepoch') AS last_visit,
  DATETIME(visits.visit_time/1000000-11644473600,'unixepoch') AS visit_date,
  urls.url AS url,
  REPLACE(urls.title,'|','/') AS title,
  urls.visit_count AS visit_count,
  visits.transition & 255 AS visit_type,
  CASE (visits.transition & 255)
  WHEN 0 THEN 'User clicked a link'
  WHEN 1 THEN 'User typed the URL in the URL bar'
  WHEN 2 THEN 'Got through a suggestion in the UI'
  WHEN 3 THEN 'Content automatically loaded in a non-toplevel frame - user may not realize'
  WHEN 4 THEN 'Subframe explicitly requested by the user'
  WHEN 5 THEN 'User typed in the URL bar and selected an entry from the list - such as a search bar'
  WHEN 6 THEN 'The start page of the browser'
  WHEN 7 THEN 'A form the user has submitted values to'
  WHEN 8 THEN 'The user reloaded the page, eg by hitting the reload button or restored a session'
  WHEN 9 THEN 'URL what was generated from a replacable keyword other than the default search provider'
  WHEN 10 THEN 'Corresponds to a visit generated from a KEYWORD' END AS type_description,
  visits.visit_duration AS visit_duration,
  CASE visit_source.source
  WHEN 0 THEN 'Synced'
  WHEN 1 THEN 'Browsed'
  WHEN 2 THEN 'Extension'
  WHEN 3 THEN 'Imported'
  WHEN 4 THEN 'Imported'
  WHEN 5 THEN 'Imported'
  END AS VisitSource
  FROM visits JOIN urls ON urls.id = visits.url LEFT JOIN visit_source ON visit_source.id = visits.id

[browsers.brave.downloads]
modules =
	base.output.JSONSink file_exists=APPEND outfile="${plugins.common.RVT_browsers.Chrome:outdir}/downloads.json"
  plugins.common.ExtractPathTerms section='browsers.parameters'
  base.mutations.AddFields section='browsers.parameters' fields='{{{{"partition":"{{partition}}", "user":"{{user}}", "browser":"brave"}}}}'
	base.input.SQLiteReader read_only=True
query =
  SELECT DATETIME(downloads.end_time/1000000-11644473600,'unixepoch') AS end,
  DATETIME(downloads.start_time/1000000-11644473600,'unixepoch') AS start,
  downloads.id, downloads_url_chains.url, downloads.total_bytes AS size, downloads.target_path AS path, downloads_url_chains.chain_index, downloads.opened
  FROM downloads, downloads_url_chains WHERE downloads_url_chains.id = downloads.id ORDER BY downloads.end_time


[browsers.brave.cookies]
modules =
	base.output.JSONSink file_exists=APPEND outfile="${plugins.common.RVT_browsers.Chrome:outdir}/cookies.json"
  plugins.common.ExtractPathTerms section='browsers.parameters'
  base.mutations.AddFields section='browsers.parameters' fields='{{{{"partition":"{{partition}}", "user":"{{user}}", "browser":"brave"}}}}'
	base.input.SQLiteReader read_only=True
query =
  SELECT DATETIME(last_access_utc/1000000-11644473600,'unixepoch') AS accessed,
  DATETIME(creation_utc/1000000-11644473600,'unixepoch') AS creation,
  host_key AS url,
  name AS cookie_name,
  value AS cookie_value
  FROM cookies

[browsers.vivaldi.history]
modules =
	base.output.JSONSink file_exists=APPEND outfile="${plugins.common.RVT_browsers.Chrome:outdir}/history.json"
  plugins.common.ExtractPathTerms section='browsers.parameters'
  base.mutations.AddFields section='browsers.parameters' fields='{{{{"partition":"{{partition}}", "user":"{{user}}", "browser":"vivaldi"}}}}'
	base.input.SQLiteReader read_only=True
query =
  SELECT DATETIME(urls.last_visit_time/1000000-11644473600,'unixepoch') AS last_visit,
  DATETIME(visits.visit_time/1000000-11644473600,'unixepoch') AS visit_date,
  urls.url AS url,
  REPLACE(urls.title,'|','/') AS title,
  urls.visit_count AS visit_count,
  visits.transition & 255 AS visit_type,
  CASE (visits.transition & 255)
  WHEN 0 THEN 'User clicked a link'
  WHEN 1 THEN 'User typed the URL in the URL bar'
  WHEN 2 THEN 'Got through a suggestion in the UI'
  WHEN 3 THEN 'Content automatically loaded in a non-toplevel frame - user may not realize'
  WHEN 4 THEN 'Subframe explicitly requested by the user'
  WHEN 5 THEN 'User typed in the URL bar and selected an entry from the list - such as a search bar'
  WHEN 6 THEN 'The start page of the browser'
  WHEN 7 THEN 'A form the user has submitted values to'
  WHEN 8 THEN 'The user reloaded the page, eg by hitting the reload button or restored a session'
  WHEN 9 THEN 'URL what was generated from a replacable keyword other than the default search provider'
  WHEN 10 THEN 'Corresponds to a visit generated from a KEYWORD' END AS type_description,
  visits.visit_duration AS visit_duration,
  CASE visit_source.source
  WHEN 0 THEN 'Synced'
  WHEN 1 THEN 'Browsed'
  WHEN 2 THEN 'Extension'
  WHEN 3 THEN 'Imported'
  WHEN 4 THEN 'Imported'
  WHEN 5 THEN 'Imported'
  END AS VisitSource
  FROM visits JOIN urls ON urls.id = visits.url LEFT JOIN visit_source ON visit_source.id = visits.id

[browsers.vivaldi.downloads]
modules =
	base.output.JSONSink file_exists=APPEND outfile="${plugins.common.RVT_browsers.Chrome:outdir}/downloads.json"
  plugins.common.ExtractPathTerms section='browsers.parameters'
  base.mutations.AddFields section='browsers.parameters' fields='{{{{"partition":"{{partition}}", "user":"{{user}}", "browser":"vivaldi"}}}}'
	base.input.SQLiteReader read_only=True
query =
  SELECT DATETIME(downloads.end_time/1000000-11644473600,'unixepoch') AS end,
  DATETIME(downloads.start_time/1000000-11644473600,'unixepoch') AS start,
  downloads.id, downloads_url_chains.url, downloads.total_bytes AS size, downloads.target_path AS path, downloads_url_chains.chain_index, downloads.opened
  FROM downloads, downloads_url_chains WHERE downloads_url_chains.id = downloads.id ORDER BY downloads.end_time

[browsers.vivaldi.cookies]
modules =
	base.output.JSONSink file_exists=APPEND outfile="${plugins.common.RVT_browsers.Chrome:outdir}/cookies.json"
  plugins.common.ExtractPathTerms section='browsers.parameters'
  base.mutations.AddFields section='browsers.parameters' fields='{{{{"partition":"{{partition}}", "user":"{{user}}", "browser":"vivaldi"}}}}'
	base.input.SQLiteReader read_only=True
query =
  SELECT DATETIME(last_access_utc/1000000-11644473600,'unixepoch') AS accessed,
  DATETIME(creation_utc/1000000-11644473600,'unixepoch') AS creation,
  host_key AS url,
  name AS cookie_name,
  value AS cookie_value
  FROM cookies

[browsers.opera.history]
modules =
	base.output.JSONSink file_exists=APPEND outfile="${plugins.common.RVT_browsers.Chrome:outdir}/history.json"
  plugins.common.ExtractPathTerms section='browsers.parameters'
  base.mutations.AddFields section='browsers.parameters' fields='{{{{"partition":"{{partition}}", "user":"{{user}}", "browser":"opera"}}}}'
	base.input.SQLiteReader read_only=True
query =
  SELECT DATETIME(urls.last_visit_time/1000000-11644473600,'unixepoch') AS last_visit,
  DATETIME(visits.visit_time/1000000-11644473600,'unixepoch') AS visit_date,
  urls.url AS url,
  REPLACE(urls.title,'|','/') AS title,
  urls.visit_count AS visit_count,
  visits.transition & 255 AS visit_type,
  CASE (visits.transition & 255)
  WHEN 0 THEN 'User clicked a link'
  WHEN 1 THEN 'User typed the URL in the URL bar'
  WHEN 2 THEN 'Got through a suggestion in the UI'
  WHEN 3 THEN 'Content automatically loaded in a non-toplevel frame - user may not realize'
  WHEN 4 THEN 'Subframe explicitly requested by the user'
  WHEN 5 THEN 'User typed in the URL bar and selected an entry from the list - such as a search bar'
  WHEN 6 THEN 'The start page of the browser'
  WHEN 7 THEN 'A form the user has submitted values to'
  WHEN 8 THEN 'The user reloaded the page, eg by hitting the reload button or restored a session'
  WHEN 9 THEN 'URL what was generated from a replacable keyword other than the default search provider'
  WHEN 10 THEN 'Corresponds to a visit generated from a KEYWORD' END AS type_description,
  visits.visit_duration AS visit_duration,
  CASE visit_source.source
  WHEN 0 THEN 'Synced'
  WHEN 1 THEN 'Browsed'
  WHEN 2 THEN 'Extension'
  WHEN 3 THEN 'Imported'
  WHEN 4 THEN 'Imported'
  WHEN 5 THEN 'Imported'
  END AS VisitSource
  FROM visits JOIN urls ON urls.id = visits.url LEFT JOIN visit_source ON visit_source.id = visits.id

[browsers.opera.downloads]
modules =
	base.output.JSONSink file_exists=APPEND outfile="${plugins.common.RVT_browsers.Chrome:outdir}/downloads.json"
  plugins.common.ExtractPathTerms section='browsers.parameters'
  base.mutations.AddFields section='browsers.parameters' fields='{{{{"partition":"{{partition}}", "user":"{{user}}", "browser":"opera"}}}}'
	base.input.SQLiteReader read_only=True
query =
  SELECT DATETIME(downloads.end_time/1000000-11644473600,'unixepoch') AS end,
  DATETIME(downloads.start_time/1000000-11644473600,'unixepoch') AS start,
  downloads.id, downloads_url_chains.url, downloads.total_bytes AS size, downloads.target_path AS path, downloads_url_chains.chain_index, downloads.opened
  FROM downloads, downloads_url_chains WHERE downloads_url_chains.id = downloads.id ORDER BY downloads.end_time

[browsers.opera.cookies]
modules =
	base.output.JSONSink file_exists=APPEND outfile="${plugins.common.RVT_browsers.Chrome:outdir}/cookies.json"
  plugins.common.ExtractPathTerms section='browsers.parameters'
  base.mutations.AddFields section='browsers.parameters' fields='{{{{"partition":"{{partition}}", "user":"{{user}}", "browser":"opera"}}}}'
	base.input.SQLiteReader read_only=True
query =
  SELECT DATETIME(last_access_utc/1000000-11644473600,'unixepoch') AS accessed,
  DATETIME(creation_utc/1000000-11644473600,'unixepoch') AS creation,
  host_key AS url,
  name AS cookie_name,
  value AS cookie_value
  FROM cookies

[browsers.edge_legacy.history]
modules =
  base.output.JSONSink file_exists=APPEND outfile="${plugins.common.RVT_browsers.Chrome:outdir}/history.json"
  plugins.common.ExtractPathTerms section='browsers.parameters'
  base.mutations.AddFields section='browsers.parameters' fields='{{{{"partition":"{{partition}}", "user":"{{user}}", "browser":"edge_legacy", "profile":"{{profile}}"}}}}'
  base.input.SQLiteReader read_only=True
query =
  SELECT DATETIME(urls.last_visit_time/1000000-11644473600,'unixepoch') AS last_visit,
  DATETIME(visits.visit_time/1000000-11644473600,'unixepoch') AS visit_date,
  urls.url AS url,
  REPLACE(urls.title,'|','/') AS title,
  urls.visit_count AS visit_count,
  visits.transition & 255 AS visit_type,
  CASE (visits.transition & 255)
  WHEN 0 THEN 'User clicked a link'
  WHEN 1 THEN 'User typed the URL in the URL bar'
  WHEN 2 THEN 'Got through a suggestion in the UI'
  WHEN 3 THEN 'Content automatically loaded in a non-toplevel frame - user may not realize'
  WHEN 4 THEN 'Subframe explicitly requested by the user'
  WHEN 5 THEN 'User typed in the URL bar and selected an entry from the list - such as a search bar'
  WHEN 6 THEN 'The start page of the browser'
  WHEN 7 THEN 'A form the user has submitted values to'
  WHEN 8 THEN 'The user reloaded the page, eg by hitting the reload button or restored a session'
  WHEN 9 THEN 'URL what was generated from a replacable keyword other than the default search provider'
  WHEN 10 THEN 'Corresponds to a visit generated from a KEYWORD' END AS type_description,
  visits.visit_duration AS visit_duration,
  CASE visit_source.source
  WHEN 0 THEN 'Synced'
  WHEN 1 THEN 'Browsed'
  WHEN 2 THEN 'Extension'
  WHEN 3 THEN 'Imported'
  WHEN 4 THEN 'Imported'
  WHEN 5 THEN 'Imported'
  END AS VisitSource
  FROM visits JOIN urls ON urls.id = visits.url LEFT JOIN visit_source ON visit_source.id = visits.id

[browsers.edge_legacy.downloads]
modules =
  base.output.JSONSink file_exists=APPEND outfile="${plugins.common.RVT_browsers.Chrome:outdir}/downloads.json"
  plugins.common.ExtractPathTerms section='browsers.parameters'
  base.mutations.AddFields section='browsers.parameters' fields='{{{{"partition":"{{partition}}", "user":"{{user}}", "browser":"edge_legacy", "profile":"{{profile}}"}}}}'
  base.input.SQLiteReader read_only=True
query =
  SELECT DATETIME(downloads.end_time/1000000-11644473600,'unixepoch') AS end,
  DATETIME(downloads.start_time/1000000-11644473600,'unixepoch') AS start,
  downloads.id, downloads_url_chains.url, downloads.total_bytes AS size, downloads.target_path AS path, downloads_url_chains.chain_index, downloads.opened
  FROM downloads, downloads_url_chains WHERE downloads_url_chains.id = downloads.id ORDER BY downloads.end_time

[browsers.edge_legacy.cookies]
modules =
  base.output.JSONSink file_exists=APPEND outfile="${plugins.common.RVT_browsers.Chrome:outdir}/cookies.json"
  plugins.common.ExtractPathTerms section='browsers.parameters'
  base.mutations.AddFields section='browsers.parameters' fields='{{{{"partition":"{{partition}}", "user":"{{user}}", "browser":"edge_legacy", "profile":"{{profile}}"}}}}'
  base.input.SQLiteReader read_only=True
query =
  SELECT DATETIME(last_access_utc/1000000-11644473600,'unixepoch') AS accessed,
  DATETIME(creation_utc/1000000-11644473600,'unixepoch') AS creation,
  host_key AS url,
  name AS cookie_name,
  value AS cookie_value
  FROM cookies

[browsers.firefox.history]
modules =
	base.output.JSONSink file_exists=APPEND outfile="${plugins.common.RVT_browsers.Firefox:outdir}/history.json"
  plugins.common.ExtractPathTerms section='browsers.parameters'
  base.mutations.AddFields section='browsers.parameters' fields='{{{{"partition":"{{partition}}", "user":"{{user}}", "browser":"firefox"}}}}'
	base.input.SQLiteReader read_only=True
query =
  SELECT DATETIME(moz_places.last_visit_date/1000000,'unixepoch') AS last_visit,
  DATETIME(moz_historyvisits.visit_date/1000000,'unixepoch') AS visit_date,
  moz_places.url,
  moz_places.title,
  moz_places.visit_count,
  moz_historyvisits.visit_type,
  CASE (moz_historyvisits.visit_type)
  WHEN 1 THEN 'The user followed a link and got a new toplevel window'
  WHEN 2 THEN 'The user typed the pages URL in the URL bar or selected it from URL bar autocomplete results, clicked on it from a history query (from the History sidebar, History menu, or history query in the personal toolbar or Places organizer'
  WHEN 3 THEN 'The user followed a bookmark to get to the page'
  WHEN 4 THEN 'Some inner content is loaded'
  WHEN 5 THEN 'Permanent redirect'
  WHEN 6 THEN 'Temporary redirect'
  WHEN 7 THEN 'Download'
  WHEN 8 THEN 'The user followed a link and got a visit in a frame'
  WHEN 9 THEN 'The page has been reloaded'
  END AS type_description
  FROM moz_places JOIN moz_historyvisits ON moz_historyvisits.place_id=moz_places.id

[browsers.firefox.downloads]
modules =
	base.output.JSONSink file_exists=APPEND outfile="${plugins.common.RVT_browsers.Firefox:outdir}/downloads.json"
  plugins.common.ExtractPathTerms section='browsers.parameters'
  base.mutations.AddFields section='browsers.parameters' fields='{{{{"partition":"{{partition}}", "user":"{{user}}", "browser":"firefox"}}}}'
	base.input.SQLiteReader read_only=True
query =
  SELECT DATETIME(moz_annos.lastModified/1000000, 'unixepoch') as end,
  DATETIME(moz_annos.dateAdded/1000000, 'unixepoch') as start,
  moz_places.id,
  moz_places.url,
  moz_annos.content as path
  FROM moz_annos JOIN moz_places
  WHERE moz_annos.place_id == moz_places.id
  AND anno_attribute_id ==
  (SELECT moz_anno_attributes.id FROM moz_anno_attributes
  	WHERE moz_anno_attributes.name LIKE "downloads/destinationFileURI")
  ORDER BY moz_annos.lastModified DESC

[browsers.firefox.cookies]
modules =
	base.output.JSONSink file_exists=APPEND outfile="${plugins.common.RVT_browsers.Firefox:outdir}/cookies.json"
  plugins.common.ExtractPathTerms section='browsers.parameters'
  base.mutations.AddFields section='browsers.parameters' fields='{{{{"partition":"{{partition}}", "user":"{{user}}", "browser":"firefox"}}}}'
	base.input.SQLiteReader read_only=True
query =
  SELECT DATETIME(lastAccessed/1000000,'unixepoch') AS accessed,
  DATETIME(creationTime/1000000,'unixepoch') AS creation,
  host as url,
  name AS cookie_name,
  value As cookie_value
  FROM moz_cookies

[browsers.palemoon.history]
modules =
	base.output.JSONSink file_exists=APPEND outfile="${plugins.common.RVT_browsers.Firefox:outdir}/history.json"
  plugins.common.ExtractPathTerms section='browsers.parameters'
  base.mutations.AddFields section='browsers.parameters' fields='{{{{"partition":"{{partition}}", "user":"{{user}}", "browser":"Pale Moon"}}}}'
	base.input.SQLiteReader read_only=True
query =
  SELECT DATETIME(moz_places.last_visit_date/1000000,'unixepoch') AS last_visit,
  DATETIME(moz_historyvisits.visit_date/1000000,'unixepoch') AS visit_date,
  moz_places.url,
  moz_places.title,
  moz_places.visit_count,
  moz_historyvisits.visit_type,
  CASE (moz_historyvisits.visit_type)
  WHEN 1 THEN 'The user followed a link and got a new toplevel window'
  WHEN 2 THEN 'The user typed the pages URL in the URL bar or selected it from URL bar autocomplete results, clicked on it from a history query (from the History sidebar, History menu, or history query in the personal toolbar or Places organizer'
  WHEN 3 THEN 'The user followed a bookmark to get to the page'
  WHEN 4 THEN 'Some inner content is loaded'
  WHEN 5 THEN 'Permanent redirect'
  WHEN 6 THEN 'Temporary redirect'
  WHEN 7 THEN 'Download'
  WHEN 8 THEN 'The user followed a link and got a visit in a frame'
  WHEN 9 THEN 'The page has been reloaded'
  END AS type_description
  FROM moz_places JOIN moz_historyvisits ON moz_historyvisits.place_id=moz_places.id

[browsers.palemoon.downloads]
modules =
	base.output.JSONSink file_exists=APPEND outfile="${plugins.common.RVT_browsers.Firefox:outdir}/downloads.json"
  plugins.common.ExtractPathTerms section='browsers.parameters'
  base.mutations.AddFields section='browsers.parameters' fields='{{{{"partition":"{{partition}}", "user":"{{user}}", "browser":"Pale Moon"}}}}'
	base.input.SQLiteReader read_only=True
query =
  SELECT DATETIME(moz_annos.lastModified/1000000, 'unixepoch') as end,
  DATETIME(moz_annos.dateAdded/1000000, 'unixepoch') as start,
  moz_places.id,
  moz_places.url,
  moz_annos.content as path
  FROM moz_annos JOIN moz_places
  WHERE moz_annos.place_id == moz_places.id
  AND anno_attribute_id ==
  (SELECT moz_anno_attributes.id FROM moz_anno_attributes
  	WHERE moz_anno_attributes.name LIKE "downloads/destinationFileURI")
  ORDER BY moz_annos.lastModified DESC

[browsers.palemoon.cookies]
modules =
	base.output.JSONSink file_exists=APPEND outfile="${plugins.common.RVT_browsers.Firefox:outdir}/cookies.json"
  plugins.common.ExtractPathTerms section='browsers.parameters'
  base.mutations.AddFields section='browsers.parameters' fields='{{{{"partition":"{{partition}}", "user":"{{user}}", "browser":"Pale Moon"}}}}'
	base.input.SQLiteReader read_only=True
query =
  SELECT DATETIME(lastAccessed/1000000,'unixepoch') AS accessed,
  DATETIME(creationTime/1000000,'unixepoch') AS creation,
  host as url,
  name AS cookie_name,
  value As cookie_value
  FROM moz_cookies

[browsers.edge.history]
modules =
	base.output.JSONSink file_exists=APPEND outfile="${plugins.common.RVT_browsers.Chrome:outdir}/history.json"
  plugins.common.ExtractPathTerms section='browsers.parameters'
  base.mutations.AddFields section='browsers.parameters' fields='{{{{"partition":"{{partition}}", "user":"{{user}}", "browser":"edge"}}}}'
	plugins.common.RVT_browsers.Edge information='history'

[browsers.edge.cookies]
modules =
	base.output.JSONSink file_exists=APPEND outfile="${plugins.common.RVT_browsers.Chrome:outdir}/cookies.json"
  plugins.common.ExtractPathTerms section='browsers.parameters'
  base.mutations.AddFields section='browsers.parameters' fields='{{{{"partition":"{{partition}}", "user":"{{user}}", "browser":"edge"}}}}'
	plugins.common.RVT_browsers.Edge information='cookies'

[browsers.edge.downloads]
modules =
  base.output.JSONSink file_exists=APPEND outfile="${plugins.common.RVT_browsers.Chrome:outdir}/downloads.json"
  plugins.common.ExtractPathTerms section='browsers.parameters'
  base.mutations.AddFields section='browsers.parameters' fields='{{{{"partition":"{{partition}}", "user":"{{user}}", "browser":"edge"}}}}'
  plugins.common.RVT_browsers.Edge information='downloads'

[browsers.internet_explorer]
modules =
	base.output.JSONSink file_exists=APPEND outfile="${plugins.common.RVT_browsers.Chrome:outdir}/history.json"
  plugins.common.ExtractPathTerms section='browsers.parameters'
  base.mutations.AddFields section='browsers.parameters' fields='{{{{"partition":"{{partition}}", "user":"{{user}}", "browser":"ie"}}}}'
	plugins.common.RVT_browsers.InternetExplorer

[browsers.safari.history_db]
modules =
;	base.output.JSONSink file_exists=APPEND outfile="${plugins.common.RVT_browsers.Safari:outdir}/history.json"
  plugins.common.ExtractPathTerms section='browsers.parameters'
  base.mutations.AddFields section='browsers.parameters' fields='{{{{"partition":"{{partition}}", "user":"{{user}}", "browser":"safari"}}}}'
	base.input.SQLiteReader read_only=True
query =
  SELECT DATETIME(v.visit_time + 978307200, 'unixepoch') as last_visit,
  i.url,
  v.title
  FROM history_items i LEFT JOIN history_visits v ON i.id = v.history_item
  ORDER BY v.visit_time DESC

[browsers.safari.history_plist]
modules =
	base.output.JSONSink file_exists=APPEND outfile="${plugins.common.RVT_browsers.Safari:outdir}/history.json"
  plugins.common.ExtractPathTerms section='browsers.parameters'
  base.mutations.AddFields section='browsers.parameters' fields='{{{{"partition":"{{partition}}", "user":"{{user}}", "browser":"safari"}}}}'
	plugins.common.RVT_browsers.Safari information='history'

[browsers.safari.downloads]
modules =
	base.output.JSONSink file_exists=APPEND outfile="${plugins.common.RVT_browsers.Safari:outdir}/downloads.json"
  plugins.common.ExtractPathTerms section='browsers.parameters'
  base.mutations.AddFields section='browsers.parameters' fields='{{{{"partition":"{{partition}}", "user":"{{user}}", "browser":"safari"}}}}'
	plugins.common.RVT_browsers.Safari information='downloads'

[browsers.safari.cookies]
modules =
	base.output.JSONSink file_exists=APPEND outfile="${plugins.common.RVT_browsers.Safari:outdir}/cookies.json"
  plugins.common.ExtractPathTerms section='browsers.parameters'
  base.mutations.AddFields section='browsers.parameters' fields='{{{{"partition":"{{partition}}", "user":"{{user}}", "browser":"safari"}}}}'
	plugins.common.RVT_browsers.Safari information='cookies'



;;;;;;;;;;; MYSTERY

[solve_case]
module: plugins.common.case_solve.Case_Solve
