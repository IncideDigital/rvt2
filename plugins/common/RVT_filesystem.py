# Copyright (C) INCIDE Digital Data S.L.
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

import os
import subprocess
import shlex
import json
import pytsk3
import datetime
from collections import defaultdict, OrderedDict
from tqdm import tqdm

import base.job
from base.commands import run_command, yield_command
from base.utils import check_directory, check_file, save_json
from plugins.common.RVT_disk import getSourceImage

# TODO: Use store.ini to save status in case long processes are interrupted
# TODO: Obtain inode_path modifying C code from sleuthkit. pytsk3 does not provide a fast method for that purpose


class FileSystem(base.job.BaseModule):
    """ This class provides a set of methods to extract general information about filesystems in every partition.

    The available methods create auxiliar files in json format.
    Once generated, they allow a fast access to information describing filesystem relations regarding:
        * Inodes and path association
        * Inodes and blocks
        * Inodes status
    Use the 'load...' methods to retrieve (or generate) the specific dictionaries.
    It also provides some methods to extract inodes or clusters.

    Parameters:
        :outdir (str): path to auxiliar output where all files generated by this modules are stored
    """

    def __init__(self, *args, disk=None, **kwargs):
        super().__init__(*args, **kwargs)
        self.disk = disk
        if disk is None:
            self.disk = getSourceImage(self.myconfig)
        self.vss = self.myflag('vss')

        # Associate a partition name with a partition object or a loop device
        self.partitions = {''.join(['p', p.partition]): p for p in self.disk.partitions}

        if not self.partitions:
            self.logger().error('No partitions found in image {}'.format(self.disk.imagefile))
            raise base.job.RVTError('No partitions found in image {}'.format(self.disk.imagefile))

        self.vss_partitions = {v: dev for p in self.partitions.values() for v, dev in p.vss_mounted.items() if dev}
        self.logger().debug('Partitions: {}'.format(self.partitions))
        self.logger().debug('Vss Partitions: {}'.format(self.vss_partitions))

        self.outdir = self.myconfig('outdir')
        check_directory(self.outdir, create=True)

    def run(self, path=""):
        """ Generate the main files describing filesystem relations.
        It is advisable to generate them separately when needed, since they are slow to run
        """

        for deleted in [False, True]:
            self.inode_path(deleted)
        self.inode_status()
        self.inode_block()

        return []

    def load_inode_from_path(self, config=None, partition=None, vss=None, deleted=None):
        """ Return dictionary relating each path with an inode"""
        self.logger().debug('config={} partition={}, vss={}, deleted={}'.format(config, partition, vss, deleted))
        return self._load_relation('inode_from_path', config, partition, vss, deleted)

    def load_path_from_inode(self, config=None, partition=None, vss=None, deleted=None):
        """ Return dictionary relating each inode in the partition with filenames. Keys are strings, not integers"""
        self.logger().debug('config={} partition={}, vss={}, deleted={}'.format(config, partition, vss, deleted))
        return self._load_relation('path_from_inode', config, partition, vss, deleted)

    def load_inode_from_block(self, config=None, partition=None, vss=None, deleted=None):
        """ Return dictionary relating each block with a list of inodes"""
        self.logger().debug('config={} partition={}, vss={}, deleted={}'.format(config, partition, vss, deleted))
        return self._load_relation('inode_from_block', config, partition, vss, deleted)

    def load_block_from_inode(self, config=None, partition=None, vss=None, deleted=None):
        """ Return dictionary relating each inode in the partition with its data blocks. Keys are strings, not integers"""
        self.logger().debug('config={} partition={}, vss={}, deleted={}'.format(config, partition, vss, deleted))
        return self._load_relation('block_from_inode', config, partition, vss, deleted)

    def load_inode_status(self, config=None, partition=None, vss=None, deleted=None):
        """ Return dictionary telling the allocation status for every inode in a partition"""
        self.logger().debug('config={} partition={}, vss={}, deleted={}'.format(config, partition, vss, deleted))
        return self._load_relation('inode_status', config, partition, vss, deleted)

    def get_inode_from_path(self, filename, partition, vss=False):
        """ Find inode associated to a filename inside a partition filesystem

        Arguments:
            :filename (str): filename to search inode
            :partition (str): Partition name where getting inode (examples: p05 or v1p04_201123_050521)
            :vss (bool): True if it's an vss
        """
        try:
            fs = self._get_filesystem(partition, vss)
        except Exception as exc:
            self.logger().warning('FileSystem object not loaded. Error: {}'.format(exc))
            return -1

        try:
            f = fs.open(filename)
            inode = f.info.meta.addr
        except Exception as exc:
            self.logger().warning('Filename or inode not found in FileSystem. Error: {}'.format(exc))
            return -1

        return inode

    def get_macb(self, file_list, vss=False):
        """ Retrieve timestamp information (MACB times) for a list of files

        Arguments:
            :file_list (list): list of filenames paths relative to casedir (example: 112233-01-1/mnt/p02/Users/myuser/Documents/mydoc.txt)
            :vss (bool): If True, look at vss partitions
        Returns:
            :dict: every key (filename) contains a list of four strings representing times
        """

        if not isinstance(file_list, list):
            raise TypeError('Expected a list object')

        filesystems, dates = {}, {}
        for file in file_list:
            try:
                part = file.split("/")[2]
                fs = filesystems.get(part, self._get_filesystem(part, vss))
            except Exception as exc:
                self.logger().warning('FileSystem object not loaded. Error: {}'.format(exc))
            try:
                f = fs.open('/'.join(file.split("/")[3:]))
                dates[file] = [datetime.datetime.fromtimestamp(f.info.meta.mtime, datetime.timezone.utc).strftime("%Y-%m-%dT%H:%M:%SZ"),
                               datetime.datetime.fromtimestamp(f.info.meta.atime, datetime.timezone.utc).strftime("%Y-%m-%dT%H:%M:%SZ"),
                               datetime.datetime.fromtimestamp(f.info.meta.ctime, datetime.timezone.utc).strftime("%Y-%m-%dT%H:%M:%SZ"),
                               datetime.datetime.fromtimestamp(f.info.meta.crtime, datetime.timezone.utc).strftime("%Y-%m-%dT%H:%M:%SZ")]
            except Exception as exc:
                self.logger().warning('Filename not found in FileSystem. Error: {}'.format(exc))
                dates[file] = ['1601-01-01T00:00:00Z'] * 4

        return dates

    def icat(self, inode, partition, output_filename=None, attribute="", vss=False):
        """ Write or return inode contents. If output_filename is set the content is written to that file and returns nothing.
            Otherwise the content is returned. Be careful with large files.
        Arguments:
            :partition (str): Partition name where getting content (examples: p05 or v1p04_201123_050521)
            :inode (int): inode number
            :output_filename (string): file where inode's content may be written
            :attribute (string): optional inode attribute (related with ADS)
            :vss (bool): True if it is an volume snapshot
        """

        try:
            fs = self._get_filesystem(partition, vss)
        except Exception as exc:
            self.logger().warning('FileSystem object not loaded. Error: {}'.format(exc))
            return -1

        try:
            f = fs.open_meta(inode=inode)
            size = f.info.meta.size
        except Exception as exc:
            self.logger().debug('Content not extracted. Error: {}'.format(exc))
            return -1

        attrId = ""
        if attribute != "":
            for attrib in f:
                if attrib.info.name == attribute.encode():
                    attrType, attrId, size = attrib.info.type, attrib.info.id, attrib.info.size
                    break

        BUFF_SIZE = 1024 * 1024
        offset = 0

        if output_filename:
            f_o = open(output_filename, "wb")
        else:
            result = b''

        try:
            while offset < size:
                data = None
                available_to_read = min(BUFF_SIZE, size - offset)
                if not attribute:
                    data = f.read_random(offset, available_to_read)
                else:
                    data = f.read_random(offset, available_to_read, attrType, attrId)
                if data is None:
                    return -1

                offset += len(data)
                if output_filename:
                    f_o.write(data)
                else:
                    result += data
        finally:
            if output_filename:
                f_o.close()

    def _get_filesystem(self, partition, vss=False):
        """ Return a pytsk3 FS_info object associated to partition. """
        if not vss:
            p = self.partitions[partition]
            if not p.isMountable:
                return -1
            if p.encrypted:
                img = pytsk3.Img_Info(p.loop)
                fs = pytsk3.FS_Info(img)
            else:
                img = pytsk3.Img_Info(p.imagefile)
                fs = pytsk3.FS_Info(img, offset=int(p.obytes))
        else:
            dev = self.vss_partitions[partition]
            img = pytsk3.Img_Info(dev)
            fs = pytsk3.FS_Info(img)
        return fs

    def cluster_extract(self, partition, cluster):
        """ Extraxt cluster content

        Parameters:
            partition (str): partition name
            cluster (str): cluster number
        Returns:
            str: binary text from a cluster
        """

        p = self.partitions[partition]
        imagetype = self.disk.imagefile.split('.')[-1]

        offset = int(cluster) * int(p.clustersize)
        if imagetype in ['dd', 'raw'] and not p.encrypted:
            image = self.disk.imagefile
            offset += p.obytes
        else:
            image = p.loop

        with open(image, "rb") as dd_img:
            dd_img.seek(offset)
            res = dd_img.read(int(p.clustersize))
            return res

    def cluster_allocation_status(self, partition, cluster):
        """ Gets cluster allocation status

        Parameters:
            partition (str): partition name
            cluster (str): cluster number
        Returns:
            str: Allocated or Not Allocated
        """

        blkstat = self.myconfig('blkstat', '/usr/local/bin/blkstat')

        p = self.partitions[partition]

        try:
            cmd = "{} -o {} {} {}".format(blkstat, str(p.osects), self.disk.imagefile, str(cluster))
            if p.encrypted:
                cmd = "sudo {} {} {}".format(blkstat, p.loop, str(cluster))

            return run_command(cmd, logger=self.logger()).split("\n")[1]
        except Exception:
            return 'Not Allocated'

    def _load_relation(self, relation, config=None, partition=None, vss=None, deleted=None):
        """ Get or generate files relating inodes and paths or blocks.

        Parameters:
            relation (str): 'inode_from_path' or 'path_from_inode'
            config (configparser): RVT configuration.
            partition (str): name identifier for partition (examples: 'p05', 'v1p02')
            vss (bool): True to retrieve Volume Shadows. Loads the configuration value if not specified.
            deleted (Boolean): If True gets deleted files inodes

        Returns:
            If relation=='path_from_inode': Dictionary relating each inode in the partition with filenames. Keys are strings, not integers.
            If relation=='inode_from_path': Dictionary relating each path with an inode
            If relation=='block_from_inode': Dictionary relating each inode in the partition with blocks containing its data.
            If relation=='inode_from_block': Dictionary relating each block with an inode
            If relation=='inode_status': Dictionary relating each inode with its allocation status
        """
        relation_functions = {'path_from_inode': self.inode_path, 'inode_from_path': self.inode_path,
                              'block_from_inode': self.inode_block, 'inode_from_block': self.inode_block,
                              'inode_status': self.inode_status}

        vss = self.vss if vss is None else vss
        partition_names = {True: self.vss_partitions, False: self.partitions}
        assert partition in partition_names[vss]
        if not vss and not self.partitions[partition].isMountable:
            self.logger().debug('Partition {} is not mountable. Returning empty dictionary'.format(partition))
            return {}

        inode_relation_file = os.path.join(self.outdir, '{}_{}{}.json'.format(partition, relation, '_deleted' if deleted else ''))

        self.logger().debug('Loading {} relation file: {}'.format(relation, inode_relation_file))
        if not check_file(inode_relation_file):
            self.logger().debug('Generating {} relation file: {}'.format(relation, inode_relation_file))
            relation_functions[relation](deleted=deleted, vss=vss)
        try:
            with open(inode_relation_file, "r") as json_file:
                return json.load(json_file)
        except Exception as exc:
            self.logger().error('{} file could not be loaded'.format(inode_relation_file))
            raise exc

    def inode_path(self, deleted=False, vss=None):
        """ Relates inodes with paths for every partition using sleuthkit fls command.
        Generates two reciprocal JSON files: inode -> path; path -> inode.
        path_from_inode: Keys are inodes (strings, not integers). Values are a list of paths
        inode_from_path: Keys are paths. Values are inodes
        Deleted files are treated apart since the associated inode may no longer contain the data
        Caution: Embedded data streams are not referenced.

        Parameters:
            deleted (bool): If True, show only deleted files
            vss (str): If True, retrieve Volume Shadows Snapshots inode path relations
        """
        vss = self.vss if vss is None else vss
        sectorsize = str(self.disk.sectorsize) if self.disk.sectorsize else '512'

        for p in self.disk.partitions:

            if not p.isMountable or p.filesystem == "NoName":  # APFS contains no I30
                continue

            if vss:
                for v, device in p.vss_mounted.items():
                    if device:
                        cmd = 'fls -{}pr -b {} {}'.format('d' if deleted else 'u', sectorsize, device)
                        self.logger().debug('Generating inode-paths association for {} files of device {}'.format('deleted' if deleted else 'allocated', device))
                        self.save_inode_path_files(*self._process_fls(cmd, deleted=deleted), partition=v, deleted=deleted)
                continue

            p_name = ''.join(['p', p.partition])
            if p.encrypted:
                cmd = 'sudo fls -{}pr -b {} {}'.format('d' if deleted else 'u', sectorsize, p.loop)
            else:
                cmd = 'fls -{}pr -o {} -b {} {}'.format('d' if deleted else 'u', int(p.obytes / int(sectorsize)), sectorsize, self.disk.imagefile)

            self.logger().debug('Generating inode-paths association for {} files of partition {}'.format('deleted' if deleted else 'allocated', p_name))
            self.save_inode_path_files(*self._process_fls(cmd, deleted=deleted), partition=p_name, deleted=deleted)

    def _process_fls(self, cmd, deleted=False):
        path_from_inode = OrderedDict()
        inode_from_path = OrderedDict()

        for line in yield_command(cmd, logger=self.logger()):
            # fls output format for NTFS: b"d/d * 59-144-6:\tSome Folder/Some file\n"  where * marks deleted files
            info, path = line.strip().split('\t')
            large_inode = info.split()[-1].rstrip(':')

            if large_inode == '0':  # Deleted entries with no associated inode
                continue
            if path.find(':') > 0:  # exclude data streams such as :Zone.Identifier or :com.dropbox.attributes from inode_fls
                continue

            try:
                inode, i_attr, i_ext = large_inode.split('-')
            except ValueError:
                inode = large_inode

            if int(inode) in path_from_inode:
                path_from_inode[int(inode)].append(path)
            else:
                path_from_inode[int(inode)] = [path]
            inode_from_path[path] = int(inode)

        if not deleted:
            # Root directory (inode) is not listed by fls. Add it.
            path_from_inode[5] = ['']
            inode_from_path[''] = 5

        return path_from_inode, inode_from_path

    def save_inode_path_files(self, path_from_inode, inode_from_path, partition, deleted=False):
        """ Save path_from_inode and inode_from_path results to JSON files. """
        # Since save_json iterates over first argument, in a dictionary it means only keys, so a generator yielding the entire dictionary 'result' is passed
        outfile = os.path.join(self.outdir, '{}_path_from_inode{}.json'.format(partition, '_deleted' if deleted else ''))
        save_json((lambda: (yield path_from_inode))(), config=self.config, outfile=outfile, file_exists='OVERWRITE')
        outfile2 = os.path.join(self.outdir, '{}_inode_from_path{}.json'.format(partition, '_deleted' if deleted else ''))
        save_json((lambda: (yield inode_from_path))(), config=self.config, outfile=outfile2, file_exists='OVERWRITE')

    def inode_status(self, **kwargs):
        """ Save files showing allocated status of every inode in a partition """
        ils = self.myconfig('ils', '/usr/local/bin/ils')

        for p in self.disk.partitions:
            if not p.isMountable:
                continue

            cmd = "{} -e -o {} {} | cut -d'|' -f1,2".format(ils, str(p.osects), self.disk.imagefile)
            if p.encrypted:
                cmd = "sudo {} -e {} | cut -d'|' -f1,2".format(ils, p.loop)
            self.logger().debug('Creating inode status for partition p{}'.format(p.partition))
            self._process_ils(cmd, p.partition)

    def _process_ils(self, cmd, partition):
        inode_status = OrderedDict()
        line_number = 0
        for line in yield_command(cmd, logger=self.logger()):
            line_number += 1
            if line_number <= 3:  # Skip first 3 lines
                continue
            inode, status = line.strip().split('|')
            inode_status[inode] = status
        outfile = os.path.join(self.outdir, "p{}_inode_status.json".format(partition))
        save_json((lambda: (yield inode_status))(), config=self.config, outfile=outfile, file_exists='OVERWRITE')

    def inode_block(self, **kwargs):
        """ Relates inodes with blocks for every partition.
        Generates two reciprocal JSON files: inode -> block; block -> inode.
        block_from_inode: Keys are inodes (strings, not integers). Values are a list of blocks
        inode_from_block: Keys are blocks. Values are a list of inodes
        """

        istat = self.myconfig('istat', '/usr/local/bin/istat')

        for p in self.disk.partitions:
            block_from_inode = OrderedDict()
            inode_from_block = OrderedDict()

            if not p.isMountable:
                continue

            inodes = self.load_inode_status(partition='p{}'.format(p.partition))

            # Relate inode with its blocks (clusters)
            for n in tqdm(inodes, total=len(inodes), desc='Inode block relation', disable=self.myflag('progress.disable', False)):
                if n == "":
                    continue
                cmd = [istat, "-o", str(p.osects), self.disk.imagefile, n]
                if p.encrypted:
                    cmd = ['sudo', istat, str(p.loop), n]
                try:
                    output_istat = run_command(cmd, logger=self.logger())
                except Exception as exc:
                    self.logger().warning(exc)
                    continue
                blocks = []
                for line in output_istat.split("\n"):
                    if line and line[0].isdigit():
                        bloks_in_line = line.split()
                        for blk in bloks_in_line:
                            if blk in inode_from_block:
                                inode_from_block[blk].append(n)
                            else:
                                inode_from_block[blk] = [n]
                        blocks.extend(bloks_in_line)
                block_from_inode[n] = blocks

            outfile = os.path.join(self.outdir, "p{}_block_from_inode.json".format(p.partition))
            save_json((lambda: (yield block_from_inode))(), config=self.config, outfile=outfile, file_exists='OVERWRITE')
            outfile = os.path.join(self.outdir, "p{}_inode_from_block.json".format(p.partition))
            save_json((lambda: (yield inode_from_block))(), config=self.config, outfile=outfile, file_exists='OVERWRITE')

    def inode_from_cluster(self, partition, cluster, inode_from_block=None):
        """ Use ifind (very slow) or a previously created file to get a list of inodes associated to a cluster (block)

        Parameters:
            partition (str): partition name
            cluster (str): cluster number
            inode_from_block (dict): associates a list of inodes with a block. Use it if provided
        Returns:
            list: list of inodes associated to a cluster
        """

        p = self.partitions[partition]
        ifind = self.myconfig('ifind', '/usr/local/bin/ifind')

        # Try to use the file if exists
        if inode_from_block:
            return inode_from_block.get(str(cluster), [''])

        # Use ifind otherwise
        cmd = '{} -o {} {} -d {}'.format(ifind, str(p.osects), self.disk.imagefile, str(cluster))
        if p.encrypted:
            cmd = 'sudo {} {} -d {}'.format(ifind, p.loop, str(cluster))

        try:
            inodes = run_command(cmd, logger=self.logger())
            return [str(int(i.split('-')[0])) for i in inodes.split('\n')[:-1]]
        except ValueError:
            return []
        except Exception as exc:
            self.logger().warning(exc)
            return []

    def create_inode_list_with_ffind(self, partition=None, device=None, deleted=False):
        """ Associate inode with paths using ffind.
        CAUTION: This method is VERY slow. Use self.inode_path instead
        """
        if partition:
            self.logger().debug('Generating inode-paths association for partition {}'.format(partition.partition))
        elif device:
            self.logger().debug('Generating inode-paths association for device {}'.format(device))
        result = defaultdict(OrderedDict)

        if self.vss:
            cmd_ils = 'ils -e {}'.format(device)
            cmd_ffind = 'ffind {} {}'.format(device)
        else:
            cmd_ils = 'ils -e -o {} {}'.format(int(partition.obytes / self.disk.sectorsize), self.disk.imagefile)
            cmd_ffind = 'ffind -o {} {}'.format(int(partition.obytes / self.disk.sectorsize), self.disk.imagefile)
        line_number = 1
        with subprocess.Popen(shlex.split(cmd_ils), stdout=subprocess.PIPE) as ils:
            for line in ils.stdout:
                # skip first 4 lines (header + inode 0)
                if line_number < 5:
                    line_number += 1
                    continue
                # ils output format for NTFS: b"1|a|0|0|1440160986|1440160986|1440160986|1440160986|555|1|4096". Look at man ils
                inode, status, _, _, _, _, _, _, _, links, _ = line.strip().decode('utf-8').split('|')
                found = True
                with subprocess.Popen(shlex.split(' '.join([cmd_ffind, str(inode)])), stdout=subprocess.PIPE) as ffind:
                    for path in ffind.stdout:
                        if path == b'File name not found for inode\n':
                            found = False
                            break
                        result[inode]['path'] = []
                        result[inode]['path'].append(path.decode().strip().strip('/'))
                if found:
                    result[inode].update([('status', status), ('links', links)])

        return result
